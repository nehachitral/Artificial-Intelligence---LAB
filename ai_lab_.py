# -*- coding: utf-8 -*-
"""AI LAB .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZYzB0DkpikCbLV44Vvhue_j81oHIpS0D
"""

def vacuum_world():
    # Initializing goal_state
    # 0 indicates Clean and 1 indicates Dirty
    goal_state = {'A': '0', 'B': '0'}
    cost = 0

    location_input = input("Enter Location of Vacuum: ")  # User input for the location of the vacuum
    status_input = input("Enter status of " + location_input + " (0 for Clean, 1 for Dirty): ")  # User input for status of the location
    status_input_complement = input("Enter status of the other room: ")  # User input for the status of the other room

    print("Initial Location Condition: " + str(goal_state))

    if location_input == 'A':
        # Location A is Dirty
        print("Vacuum is placed in Location A")
        if status_input == '1':
            print("Location A is Dirty.")
            # Suck the dirt and mark it as clean
            goal_state['A'] = '0'
            cost += 2  # Cost for suck
            print("Cost for CLEANING A: " + str(cost))
            print("Location A has been Cleaned.")

        if status_input_complement == '1':
            # If B is Dirty
            print("Location B is Dirty.")
            print("Moving right to Location B.")
            cost += 1  # Cost for moving right
            print("COST for moving RIGHT: " + str(cost))
            # Suck the dirt and mark it as clean
            goal_state['B'] = '0'
            cost += 2  # Cost for suck
            print("COST for SUCK: " + str(cost))
            print("Location B has been Cleaned.")
        else:
            print("No action. Location B is already clean.")

    elif location_input == 'B':
        print("Vacuum is placed in Location B")
        if status_input == '1':
            print("Location B is Dirty.")
            # Suck the dirt and mark it as clean
            goal_state['B'] = '0'
            cost += 2  # Cost for suck
            print("COST for CLEANING B: " + str(cost))
            print("Location B has been Cleaned.")

        if status_input_complement == '1':
            # If A is Dirty
            print("Location A is Dirty.")
            print("Moving left to Location A.")
            cost += 1  # Cost for moving left
            print("COST for moving LEFT: " + str(cost))
            # Suck the dirt and mark it as clean
            goal_state['A'] = '0'
            cost += 2  # Cost for suck
            print("COST for SUCK: " + str(cost))
            print("Location A has been Cleaned.")
        else:
            print("No action. Location A is already clean.")

    # Done cleaning
    print("GOAL STATE: ")
    print(goal_state)
    print("Performance Measurement: " + str(cost))

# Call the function to run the vacuum cleaner agent
vacuum_world()

board = {1: ' ', 2: ' ', 3: ' ',
         4: ' ', 5: ' ', 6: ' ',
         7: ' ', 8: ' ', 9: ' '}

def printBoard(board):
    print(board[1] + '|' + board[2] + '|' + board[3])
    print('-+-+-')
    print(board[4] + '|' + board[5] + '|' + board[6])
    print('-+-+-')
    print(board[7] + '|' + board[8] + '|' + board[9])
    print('\n')

def spaceFree(pos):
    return board[pos] == ' '

def checkWin():
    if (board[1] == board[2] and board[1] == board[3] and board[1] != ' '):
        return True
    elif (board[4] == board[5] and board[4] == board[6] and board[4] != ' '):
        return True
    elif (board[7] == board[8] and board[7] == board[9] and board[7] != ' '):
        return True
    elif (board[1] == board[5] and board[1] == board[9] and board[1] != ' '):
        return True
    elif (board[3] == board[5] and board[3] == board[7] and board[3] != ' '):
        return True
    elif (board[1] == board[4] and board[1] == board[7] and board[1] != ' '):
        return True
    elif (board[2] == board[5] and board[2] == board[8] and board[2] != ' '):
        return True
    elif (board[3] == board[6] and board[3] == board[9] and board[3] != ' '):
        return True
    else:
        return False

def checkMoveForWin(move):
    if (board[1] == board[2] and board[1] == board[3] and board[1] == move):
        return True
    elif (board[4] == board[5] and board[4] == board[6] and board[4] == move):
        return True
    elif (board[7] == board[8] and board[7] == board[9] and board[7] == move):
        return True
    elif (board[1] == board[5] and board[1] == board[9] and board[1] == move):
        return True
    elif (board[3] == board[5] and board[3] == board[7] and board[3] == move):
        return True
    elif (board[1] == board[4] and board[1] == board[7] and board[1] == move):
        return True
    elif (board[2] == board[5] and board[2] == board[8] and board[2] == move):
        return True
    elif (board[3] == board[6] and board[3] == board[9] and board[3] == move):
        return True
    else:
        return False

def checkDraw():
    for key in board.keys():
        if board[key] == ' ':
            return False
    return True

def insertLetter(letter, position):
    if spaceFree(position):
        board[position] = letter
        printBoard(board)

        if checkDraw():
            print('Draw!')
            return True
        elif checkWin():
            if letter == 'X':
                print('Bot wins!')
            else:
                print('You win!')
            return True
    else:
        print('Position taken, please pick a different position.')
        position = int(input('Enter new position: '))
        return insertLetter(letter, position)

    return False

def resetBoard():
    global board
    board = {1: ' ', 2: ' ', 3: ' ',
             4: ' ', 5: ' ', 6: ' ',
             7: ' ', 8: ' ', 9: ' '}

player = 'O'
bot = 'X'

def playerMove():
    position = int(input('Enter position for O: '))
    return insertLetter(player, position)

def compMove():
    bestScore = -1000
    bestMove = 0
    for key in board.keys():
        if board[key] == ' ':
            board[key] = bot
            score = minimax(board, False)
            board[key] = ' '
            if score > bestScore:
                bestScore = score
                bestMove = key

    return insertLetter(bot, bestMove)

def minimax(board, isMaximizing):
    if checkMoveForWin(bot):
        return 1
    elif checkMoveForWin(player):
        return -1
    elif checkDraw():
        return 0

    if isMaximizing:
        bestScore = -1000
        for key in board.keys():
            if board[key] == ' ':
                board[key] = bot
                score = minimax(board, False)
                board[key] = ' '
                bestScore = max(score, bestScore)
        return bestScore
    else:
        bestScore = 1000
        for key in board.keys():
            if board[key] == ' ':
                board[key] = player
                score = minimax(board, True)
                board[key] = ' '
                bestScore = min(score, bestScore)
        return bestScore

while True:
    resetBoard()
    print("New Game!")
    printBoard(board)

    game_over = False
    while not game_over:
        game_over = compMove()  # Bot's move
        if not game_over:
            game_over = playerMove()  # Player's move

    # Ask the user if they want to play again
    play_again = input("Do you want to play again? (yes/no): ").lower()
    if play_again != 'yes':
        print("Thanks for playing!")
        break

#AI-LAB 2

from collections import deque

# Function to check if the current state is the goal state
def is_goal(state, goal_state):
    return state == goal_state

# Function to get the possible moves from the current state
def get_neighbors(state):
    neighbors = []
    index = state.index(0)  # Find the blank (0)
    row, col = divmod(index, 3)

    # Define possible moves (up, down, left, right)
    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    for move in moves:
        new_row, new_col = row + move[0], col + move[1]

        if 0 <= new_row < 3 and 0 <= new_col < 3:
            new_index = new_row * 3 + new_col
            new_state = list(state)
            new_state[index], new_state[new_index] = new_state[new_index], new_state[index]
            neighbors.append(tuple(new_state))
    return neighbors

# Function to print the state in a 3x3 format
def print_state(state):
    for i in range(0, 9, 3):
        print(state[i:i+3])
    print()  # Blank line for readability

# BFS algorithm to solve the 8-puzzle
def bfs(start, goal):
    visited = set()
    queue = deque([(start, [])])

    while queue:
        current_state, path = queue.popleft()

        if current_state in visited:
            continue

        visited.add(current_state)

        if is_goal(current_state, goal):
            return path + [current_state]

        for neighbor in get_neighbors(current_state):
            if neighbor not in visited:
                queue.append((neighbor, path + [current_state]))

    return None  # If no solution found

# Function to take 8-puzzle input from the user
def input_puzzle(prompt):
    print(prompt)
    puzzle = []
    for i in range(3):
        row = input(f"Enter row {i+1} (3 numbers separated by spaces): ").split()
        puzzle.extend([int(x) for x in row])
    return tuple(puzzle)

# Main code
start_state = input_puzzle("Enter the start state (use 0 for the blank space):")
goal_state = input_puzzle("Enter the goal state (use 0 for the blank space):")

bfs_solution = bfs(start_state, goal_state)

if bfs_solution:
    print("BFS Solution found! Steps:")
    for i, step in enumerate(bfs_solution):
        print(f"Step {i + 1}:")
        print_state(step)
else:
    print("No solution found using BFS.")

from collections import deque

# Function to check if the current state is the goal state
def is_goal(state, goal_state):
    return state == goal_state

# Function to get the possible moves from the current state
def get_neighbors(state):
    neighbors = []
    index = state.index(0)  # Find the blank (0)
    row, col = divmod(index, 3)

    # Define possible moves (up, down, left, right)
    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    for move in moves:
        new_row, new_col = row + move[0], col + move[1]

        if 0 <= new_row < 3 and 0 <= new_col < 3:
            new_index = new_row * 3 + new_col
            new_state = list(state)
            new_state[index], new_state[new_index] = new_state[new_index], new_state[index]
            neighbors.append(tuple(new_state))
    return neighbors

# Function to print the state in a 3x3 format
def print_state(state):
    for i in range(0, 9, 3):
        print(state[i:i+3])
    print()  # Blank line for readability

# DFS algorithm to solve the 8-puzzle
def dfs(start, goal):
    visited = set()
    stack = [(start, [])]

    while stack:
        current_state, path = stack.pop()

        if current_state in visited:
            continue

        visited.add(current_state)

        if is_goal(current_state, goal):
            return path + [current_state]

        for neighbor in get_neighbors(current_state):
            if neighbor not in visited:
                stack.append((neighbor, path + [current_state]))

    return None  # If no solution found

# Function to take 8-puzzle input from the user
def input_puzzle(prompt):
    print(prompt)
    puzzle = []
    for i in range(3):
        row = input(f"Enter row {i + 1} (3 numbers separated by spaces): ").split()
        puzzle.extend([int(x) for x in row])
    return tuple(puzzle)

# Function to select goal state
def select_goal_state():
    print("Select a goal state:")
    print("1. Goal State:")
    print("   0 1 2")
    print("   3 4 5")
    print("   6 7 8")
    print("2. Goal State:")
    print("   1 2 3")
    print("   4 5 6")
    print("   7 8 0")
    choice = input("Enter 1 or 2: ")
    if choice == '1':
        return (0, 1, 2, 3, 4, 5, 6, 7, 8)
    else:
        return (1, 2, 3, 4, 5, 6, 7, 8, 0)

# Main code
start_state = input_puzzle("Enter the start state (use 0 for the blank space):")
goal_state = select_goal_state()

print("\nSolving using DFS...")
dfs_solution = dfs(start_state, goal_state)

if dfs_solution:
    print("DFS Solution found! Steps:")
    for i, step in enumerate(dfs_solution):
        print(f"Step {i + 1}:")
        print_state(step)
else:
    print("No solution found using DFS.")